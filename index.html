<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FFT Image Encoder/Decoder — Camera ZIP Mode</title>
<style>
  :root{--bg:#0f1720;--card:#0b1220;--accent:#3b82f6;--muted:#94a3b8;color-scheme:dark}
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,Arial;background:linear-gradient(180deg,#071029 0%, #081425 100%);color:#e6eef8}
  .container{max-width:1220px;margin:22px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.7)}
  h1{margin:0 0 12px;font-size:20px}
  .grid{display:grid;grid-template-columns:340px 1fr;gap:18px}
  .panel{background:var(--card);padding:14px;border-radius:10px}
  label{display:block;margin:8px 0;font-size:13px;color:var(--muted)}
  .controls button, .controls input[type=file]{width:100%;margin-top:8px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081827;color:#dff;cursor:pointer}
  .controls select, .controls textarea{width:100%;padding:8px;border-radius:8px}
  .previewCanvases{display:flex;flex-wrap:wrap;gap:10px}
  canvas{background:#fff;border-radius:6px;image-rendering:pixelated}
  .smallCanvas{width:160px;height:160px;object-fit:contain}
  .log{height:200px;overflow:auto;background:#071022;padding:10px;border-radius:8px;font-size:12px;color:#9fb7d9}
  .filesRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .filesRow button, .links a{padding:8px 10px;border-radius:8px;background:#0b2b3b;border:1px solid rgba(255,255,255,0.03);color:#dff;text-decoration:none}
  .links{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .reconWrap{display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap}
  .reconImg{border-radius:8px;max-width:320px;border:1px solid rgba(255,255,255,0.04)}
  .base64Box{margin-top:12px}
  footer{margin-top:12px;font-size:12px;color:var(--muted)}
  @media(max-width:900px){.grid{grid-template-columns:1fr;}}
  /* camera panel styling */
  #camPreview{border-radius:8px;border:1px solid rgba(255,255,255,0.04)}
  #cameraPanel .status{color:var(--muted);font-size:13px;margin-top:8px}
</style>
</head>
<body>
  <div class="container">
    <h1>FFT Image Encoder/Decoder — Camera ZIP Mode</h1>
    <div class="grid">
      <div class="panel">
        <div class="controls">
          <label>1. Выберите изображение (jpg/png)</label>
          <input id="fileInput" type="file" accept="image/*" />
          <label>2. Режим сохранения (влияет на генерируемые ссылки)</label>
          <select id="saveMode">
            <option value="6">6 файлов (24‑bit, high precision)</option>
            <option value="2">2 файла RGB (8‑bit, compact)</option>
          </select>
          <label>3. Действия</label>
          <button id="doFft">Выполнить FFT</button>
          <div style="height:8px"></div>
          <button id="saveAll">Скачать сейчас (по режиму)</button>
          <div style="height:8px"></div>
          <button id="saveZip">Сохранить ZIP (6 файлов store)</button>
          <div style="height:8px"></div>
          <label>4. Загрузить PNG / ZIP (для восстановления)</label>
          <input id="loadFiles" type="file" multiple accept=".png,.zip,image/png" />
        </div>

        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />

        <label>Логи</label>
        <div id="log" class="log" aria-live="polite"></div>
      </div>

      <div class="panel">
        <label>Preview / Visualization</label>
        <div class="previewCanvases" id="previewCanvases"></div>

        <div id="generatedLinks">
          <label style="margin-top:12px">Сгенерированные картинки (открыть / скачать)</label>
          <div class="links" id="linksArea"></div>
        </div>

        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />

        <label>Восстановленное изображение</label>
        <div class="reconWrap">
          <canvas id="canvasRecon" width="1024" height="1024" style="display:none"></canvas>
          <img id="imgRecon" class="reconImg" alt="reconstructed image" />
          <div>
            <div style="margin-bottom:8px"><strong>Скачивание</strong></div>
            <div class="filesRow">
              <button id="dlRecon">Скачать восстановленное PNG</button>
              <button id="dlReconData">Копировать dataURL</button>
            </div>
          </div>
        </div>

        <div class="base64Box">
          <label style="margin-top:12px">Base64 / dataURL → PNG</label>
          <textarea id="base64in" rows="4" placeholder="Вставьте data:image/png;base64,... или чистый base64" ></textarea>
          <div style="display:flex;gap:8px;margin-top:6px">
            <button id="convBase64">Convert</button>
            <button id="clearBase64">Clear</button>
          </div>
          <div id="base64Preview" style="margin-top:8px"></div>
        </div>

        <!-- Camera UI -->
        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />
        <label>Camera ZIP Mode (24‑bit)</label>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button id="camStartBtn">Start Camera</button>
          <button id="camStopBtn" disabled>Stop Camera</button>
          <button id="camCaptureZipBtn" disabled>Capture & ZIP (24‑bit)</button>
        </div>
        <div style="margin-top:8px;display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap">
          <video id="camPreview" autoplay playsinline style="width:320px;height:240px;background:#000;display:none"></video>
          <canvas id="camCanvas" width="1024" height="1024" style="display:none"></canvas>
          <div id="camStatus" class="status">Camera stopped</div>
        </div>

      </div>
    </div>

    <footer>После FFT автоматически генерируются ссылки на 6 или 2 файла в зависимости от режима; восстановление поддерживает автоматическое распознавание набора файлов; есть конвертер base64→PNG и режим камеры (Capture → 6 PNG → ZIP)</footer>
  </div>

<script>
/* =========================
   Полный скрипт приложения
   (FFT, кодирование, декодирование, ZIP, ссылки, base64)
   В конце — интегрированный Camera ZIP блок (без изменения основной логики)
   ========================= */

/* Константы */
const W = 1024, H = 1024;
const METAPIXELS = { '6file': 6, 'amp_rgb': 9, 'phase_rgb': 17 };

/* UI элементы */
const LOG = document.getElementById('log');
const fileInput = document.getElementById('fileInput');
const doFftBtn = document.getElementById('doFft');
const saveAllBtn = document.getElementById('saveAll');
const saveZipBtn = document.getElementById('saveZip');
const previewCanvases = document.getElementById('previewCanvases');
const saveModeSelect = document.getElementById('saveMode');
const loadFilesInput = document.getElementById('loadFiles');
const canvasRecon = document.getElementById('canvasRecon');
const imgRecon = document.getElementById('imgRecon');
const dlRecon = document.getElementById('dlRecon');
const dlReconData = document.getElementById('dlReconData');
const linksArea = document.getElementById('linksArea');
const base64in = document.getElementById('base64in');
const convBase64 = document.getElementById('convBase64');
const clearBase64 = document.getElementById('clearBase64');
const base64Preview = document.getElementById('base64Preview');

function log(...args){ const t=new Date().toLocaleTimeString(); LOG.innerText = `[${t}] `+args.join(' ') + '\n' + LOG.innerText; }

/* состояние */
let loadedImage = null;
let rFloat=null,gFloat=null,bFloat=null;
let amp={r:null,g:null,b:null}, phase={r:null,g:null,b:null};
let ampMax={r:0,g:0,b:0}, phaseMin={r:0,g:0,b:0}, phaseMax={r:0,g:0,b:0};

/* утилиты */
function timestampSuffix(){
  const d = new Date();
  return `${String(d.getDate()).padStart(2,'0')}${String(d.getMonth()+1).padStart(2,'0')}${d.getFullYear()}_${String(d.getHours()).padStart(2,'0')}${String(d.getMinutes()).padStart(2,'0')}`;
}
function clampByte(x){ return Math.max(0,Math.min(255,x|0)); }

/* Превью канвасы */
function makePreviewCanvases(){
  previewCanvases.innerHTML='';
  const names=['amp_r','phase_r','amp_g','phase_g','amp_b','phase_b'];
  names.forEach(n=>{
    const c=document.createElement('canvas'); c.width=W; c.height=H; c.className='smallCanvas';
    c.title=n; c.style.background='#111';
    previewCanvases.appendChild(c);
    const label=document.createElement('div'); label.style.color='#94a3b8'; label.style.fontSize='12px'; label.style.marginTop='4px';
    label.innerText=n;
    previewCanvases.appendChild(label);
  });
}
makePreviewCanvases();

/* Подготовка изображения к 1024x1024 */
function prepareImageTo1024(img){
  const tmp = document.createElement('canvas');
  tmp.width = W; tmp.height = H;
  const ctx = tmp.getContext('2d',{willReadFrequently:true});
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,W,H);
  const iw = img.width, ih = img.height;
  const scale = Math.max(1, Math.max(iw/ W, ih/ H));
  const nw = Math.round(iw / scale);
  const nh = Math.round(ih / scale);
  const dx = Math.floor((W - nw) / 2), dy = Math.floor((H - nh) / 2);
  ctx.drawImage(img, 0,0,iw,ih, dx,dy, nw,nh);
  const id = ctx.getImageData(0,0,W,H);
  rFloat = new Float32Array(W*H);
  gFloat = new Float32Array(W*H);
  bFloat = new Float32Array(W*H);
  const d = id.data;
  for(let i=0, p=0; i<W*H; i++, p+=4){
    rFloat[i] = d[p] / 255;
    gFloat[i] = d[p+1] / 255;
    bFloat[i] = d[p+2] / 255;
  }
  const showCanvas = previewCanvases.querySelector('canvas');
  if(showCanvas){
    const sctx = showCanvas.getContext('2d');
    sctx.putImageData(id,0,0);
  }
}

/* Загрузка файла изображения */
fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  log('Selected', f.name);
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    URL.revokeObjectURL(url);
    loadedImage = img;
    prepareImageTo1024(img);
    log('Image prepared to 1024x1024 buffer');
  };
  img.onerror = ()=>{ log('Image load error'); };
  img.src = url;
});

/* === FFT примитивы === */
function bitReverseIndices(n){
  const rev = new Uint32Array(n);
  const bits = Math.log2(n)|0;
  for(let i=0;i<n;i++){
    let x = i, r = 0;
    for(let j=0;j<bits;j++){
      r = (r<<1) | (x & 1);
      x >>= 1;
    }
    rev[i] = r;
  }
  return rev;
}

function fft1d(re, im, n, inverse=false){
  const rev = bitReverseIndices(n);
  const rtmp = new Float32Array(n);
  const itmp = new Float32Array(n);
  for(let i=0;i<n;i++){
    rtmp[i] = re[rev[i]];
    itmp[i] = im[rev[i]];
  }
  re.set(rtmp); im.set(itmp);
  for(let len=2; len<=n; len<<=1){
    const half = len>>1;
    const angSign = inverse ? 2*Math.PI/len : -2*Math.PI/len;
    for(let k=0;k<n;k+=len){
      for(let j=0;j<half;j++){
        const index1 = k + j;
        const index2 = index1 + half;
        const angle = angSign * j;
        const wr = Math.cos(angle), wi = Math.sin(angle);
        const vr = wr * re[index2] - wi * im[index2];
        const vi = wr * im[index2] + wi * re[index2];
        const ur = re[index1], ui = im[index1];
        re[index1] = ur + vr;
        im[index1] = ui + vi;
        re[index2] = ur - vr;
        im[index2] = ui - vi;
      }
    }
  }
  if(inverse){
    const invN = 1/n;
    for(let i=0;i<n;i++){ re[i]*=invN; im[i]*=invN; }
  }
}

function fft2d(re, im, inverse=false){
  const rowRe = new Float32Array(W);
  const rowIm = new Float32Array(W);
  for(let y=0;y<H;y++){
    const base = y*W;
    for(let x=0;x<W;x++){ rowRe[x] = re[base + x]; rowIm[x] = im[base + x]; }
    fft1d(rowRe, rowIm, W, inverse);
    for(let x=0;x<W;x++){ re[base + x] = rowRe[x]; im[base + x] = rowIm[x]; }
  }
  const colRe = new Float32Array(H);
  const colIm = new Float32Array(H);
  for(let x=0;x<W;x++){
    for(let y=0;y<H;y++){ const p = y*W + x; colRe[y] = re[p]; colIm[y] = im[p]; }
    fft1d(colRe, colIm, H, inverse);
    for(let y=0;y<H;y++){ const p = y*W + x; re[p] = colRe[y]; im[p] = colIm[y]; }
  }
}

/* === Запуск FFT и сбор amp/phase === */
doFftBtn.addEventListener('click', async ()=>{
  if(!rFloat){ log('No image loaded'); return; }
  log('Starting FFT (this may take some seconds)...');
  const reR = new Float32Array(W*H), imR = new Float32Array(W*H);
  const reG = new Float32Array(W*H), imG = new Float32Array(W*H);
  const reB = new Float32Array(W*H), imB = new Float32Array(W*H);
  reR.set(rFloat); reG.set(gFloat); reB.set(bFloat);
  const t0 = performance.now();
  fft2d(reR, imR, false);
  fft2d(reG, imG, false);
  fft2d(reB, imB, false);
  const t1 = performance.now();
  log('FFT done in', Math.round(t1-t0), 'ms');
  amp.r = new Float32Array(W*H); phase.r = new Float32Array(W*H);
  amp.g = new Float32Array(W*H); phase.g = new Float32Array(W*H);
  amp.b = new Float32Array(W*H); phase.b = new Float32Array(W*H);
  ampMax.r = 0; ampMax.g = 0; ampMax.b = 0;
  phaseMin.r =  Infinity; phaseMin.g =  Infinity; phaseMin.b =  Infinity;
  phaseMax.r = -Infinity; phaseMax.g = -Infinity; phaseMax.b = -Infinity;
  for(let i=0;i<W*H;i++){
    const ar = Math.hypot(reR[i], imR[i]);
    const ag = Math.hypot(reG[i], imG[i]);
    const ab = Math.hypot(reB[i], imB[i]);
    amp.r[i]=ar; amp.g[i]=ag; amp.b[i]=ab;
    if(ar>ampMax.r) ampMax.r=ar;
    if(ag>ampMax.g) ampMax.g=ag;
    if(ab>ampMax.b) ampMax.b=ab;
    const pr = Math.atan2(imR[i], reR[i]);
    const pg = Math.atan2(imG[i], reG[i]);
    const pb = Math.atan2(imB[i], reB[i]);
    phase.r[i]=pr; phase.g[i]=pg; phase.b[i]=pb;
    if(pr<phaseMin.r) phaseMin.r=pr; if(pr>phaseMax.r) phaseMax.r=pr;
    if(pg<phaseMin.g) phaseMin.g=pg; if(pg>phaseMax.g) phaseMax.g=pg;
    if(pb<phaseMin.b) phaseMin.b=pb; if(pb>phaseMax.b) phaseMax.b=pb;
  }
  ['r','g','b'].forEach(ch=>{
    if(!isFinite(phaseMin[ch]) || !isFinite(phaseMax[ch]) || Math.abs(phaseMax[ch]-phaseMin[ch])<1e-12){
      phaseMin[ch] = -Math.PI; phaseMax[ch] = Math.PI;
    }
  });
  log('Amp maxima', ampMax.r.toFixed(6), ampMax.g.toFixed(6), ampMax.b.toFixed(6));
  visualizeAll();
  window._fftState = { amp, phase, ampMax, phaseMin, phaseMax };
  await generateAndShowLinks(saveModeSelect.value);
});

/* === Visualization === */
function visualizeAll(){
  const canvases = Array.from(previewCanvases.querySelectorAll('canvas'));
  const toDraw = [
    {arr:amp.r, scale:()=>ampMax.r, title:'amp_r', phase:false},
    {arr:phase.r, scale:()=>[phaseMin.r,phaseMax.r], title:'phase_r', phase:true},
    {arr:amp.g, scale:()=>ampMax.g, title:'amp_g', phase:false},
    {arr:phase.g, scale:()=>[phaseMin.g,phaseMax.g], title:'phase_g', phase:true},
    {arr:amp.b, scale:()=>ampMax.b, title:'amp_b', phase:false},
    {arr:phase.b, scale:()=>[phaseMin.b,phaseMax.b], title:'phase_b', phase:true},
  ];
  for(let i=0;i<canvases.length;i++){
    const c = canvases[i];
    if(!toDraw[i]) continue;
    const ctx = c.getContext('2d');
    const id = ctx.createImageData(W,H);
    const arr = toDraw[i].arr;
    if(!arr){ ctx.clearRect(0,0,W,H); continue; }
    if(!toDraw[i].phase){
      const maxv = toDraw[i].scale() || 1;
      for(let p=0, q=0; p<W*H; p++, q+=4){
        const v = maxv>0 ? Math.min(1, arr[p]/maxv) : 0;
        const u = Math.round(v*255);
        id.data[q]=id.data[q+1]=id.data[q+2]=u; id.data[q+3]=255;
      }
    } else {
      const [mn,mx] = toDraw[i].scale();
      const denom = (mx - mn) || (2*Math.PI);
      for(let p=0, q=0; p<W*H; p++, q+=4){
        const v = (arr[p]-mn)/denom;
        const u = Math.round(Math.max(0,Math.min(1,v))*255);
        id.data[q]=id.data[q+1]=id.data[q+2]=u; id.data[q+3]=255;
      }
    }
    ctx.putImageData(id,0,0);
  }
}

/* === Encoding helpers === */
function float64ToBytesLE(x){
  const buf = new ArrayBuffer(8);
  new DataView(buf).setFloat64(0, x, true);
  return new Uint8Array(buf);
}
function writeMetadataIntoPixelArray(pixelUint8, metaBytes, metaPixels){
  for(let i=0;i<metaPixels;i++){
    const byteIndex = i*3;
    const base = i*4;
    pixelUint8[base+3] = 255;
    pixelUint8[base+0] = metaBytes[byteIndex]   || 0;
    pixelUint8[base+1] = metaBytes[byteIndex+1] || 0;
    pixelUint8[base+2] = metaBytes[byteIndex+2] || 0;
  }
}
function canvasToBlob(canvas, type='image/png'){ return new Promise(res=>canvas.toBlob(res, type)); }

async function buildCanvasWithMeta(bodyPixelFn, metaBytes, metaPixels){
  const cvs = document.createElement('canvas');
  cvs.width = W; cvs.height = H+1;
  const ctx = cvs.getContext('2d');
  const imgd = ctx.createImageData(cvs.width, cvs.height);
  const pixels = imgd.data;
  writeMetadataIntoPixelArray(pixels, metaBytes, metaPixels);
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const i = ((y+1)*cvs.width + x)*4;
      const idx = y*W + x;
      const rgb = bodyPixelFn(idx);
      pixels[i]   = rgb[0];
      pixels[i+1] = rgb[1];
      pixels[i+2] = rgb[2];
      pixels[i+3] = 255;
    }
  }
  ctx.putImageData(imgd, 0, 0);
  return cvs;
}

/* === Build 6 files (24-bit) === */
async function build6Files(state){
  const files = [];
  const codes = { amp_r:1, phase_r:2, amp_g:3, phase_g:4, amp_b:5, phase_b:6 };
  for(const key of ['r','g','b']){
    {
      const metaBytes = new Uint8Array(18);
      const aMaxBytes = float64ToBytesLE(state.ampMax[key]);
      metaBytes.set(aMaxBytes, 0);
      const zeroBytes = float64ToBytesLE(0.0);
      metaBytes.set(zeroBytes, 8);
      metaBytes[16] = codes[`amp_${key}`];
      const bodyFn = (idx)=>{
        const maxv = state.ampMax[key] || 1;
        const norm = maxv>0 ? Math.min(1, state.amp[key][idx]/maxv) : 0;
        const v24 = Math.round(norm * 16777215);
        const R = (v24 >> 16) & 0xFF;
        const G = (v24 >> 8) & 0xFF;
        const B = v24 & 0xFF;
        return [R,G,B];
      };
      const cvs = await buildCanvasWithMeta(bodyFn, metaBytes, METAPIXELS['6file']);
      const blob = await canvasToBlob(cvs);
      const name = `amp_${key}_${timestampSuffix()}.png`;
      files.push({name, blob});
      log('Built', name);
    }
    {
      const metaBytes = new Uint8Array(18);
      const mn = state.phaseMin[key], mx = state.phaseMax[key];
      const mnB = float64ToBytesLE(mn); metaBytes.set(mnB,0);
      const mxB = float64ToBytesLE(mx); metaBytes.set(mxB,8);
      metaBytes[16] = codes[`phase_${key}`];
      const bodyFn = (idx)=>{
        const denom = (state.phaseMax[key] - state.phaseMin[key]) || (2*Math.PI);
        const norm = (state.phase[key][idx] - state.phaseMin[key]) / denom;
        const v24 = Math.round(Math.max(0,Math.min(1,norm)) * 16777215);
        const R = (v24 >> 16) & 0xFF;
        const G = (v24 >> 8) & 0xFF;
        const B = v24 & 0xFF;
        return [R,G,B];
      };
      const cvs = await buildCanvasWithMeta(bodyFn, metaBytes, METAPIXELS['6file']);
      const blob = await canvasToBlob(cvs);
      const name = `phase_${key}_${timestampSuffix()}.png`;
      files.push({name, blob});
      log('Built', name);
    }
  }
  return files;
}

/* === Build 2-file compact === */
async function build2Files(state){
  const files = [];
  {
    const metaBytes = new Uint8Array(27);
    let off = 0;
    for(const ch of ['r','g','b']){
      metaBytes.set(float64ToBytesLE(state.ampMax[ch]), off);
      off += 8;
    }
    metaBytes[24] = 21;
    const bodyFn = (idx)=>{
      const r = state.ampMax.r>0 ? Math.round(Math.max(0,Math.min(1,state.amp.r[idx]/state.ampMax.r))*255) : 0;
      const g = state.ampMax.g>0 ? Math.round(Math.max(0,Math.min(1,state.amp.g[idx]/state.ampMax.g))*255) : 0;
      const b = state.ampMax.b>0 ? Math.round(Math.max(0,Math.min(1,state.amp.b[idx]/state.ampMax.b))*255) : 0;
      return [r,g,b];
    };
    const cvs = await buildCanvasWithMeta(bodyFn, metaBytes, METAPIXELS['amp_rgb']);
    const blob = await canvasToBlob(cvs);
    const name = `amp_rgb_${timestampSuffix()}.png`;
    files.push({name, blob});
    log('Built', name);
  }
  {
    const metaBytes = new Uint8Array(51);
    let off = 0;
    for(const ch of ['r','g','b']){
      metaBytes.set(float64ToBytesLE(phaseMin[ch]), off); off+=8;
      metaBytes.set(float64ToBytesLE(phaseMax[ch]), off); off+=8;
    }
    metaBytes[48] = 22;
    const bodyFn = (idx)=>{
      const rr = clampPhaseTo8(phase.r[idx], phaseMin.r, phaseMax.r);
      const gg = clampPhaseTo8(phase.g[idx], phaseMin.g, phaseMax.g);
      const bb = clampPhaseTo8(phase.b[idx], phaseMin.b, phaseMax.b);
      return [rr,gg,bb];
    };
    const cvs = await buildCanvasWithMeta(bodyFn, metaBytes, METAPIXELS['phase_rgb']);
    const blob = await canvasToBlob(cvs);
    const name = `phase_rgb_${timestampSuffix()}.png`;
    files.push({name, blob});
    log('Built', name);
  }
  return files;
}
function clampPhaseTo8(val, mn, mx){
  const denom = (mx-mn) || (2*Math.PI);
  const norm = (val - mn) / denom;
  return Math.round(Math.max(0,Math.min(1,norm)) * 255);
}

/* === Save handlers and link generation === */
saveAllBtn.addEventListener('click', async ()=>{
  if(!window._fftState){ log('No FFT state: run FFT first'); return; }
  const mode = saveModeSelect.value;
  if(mode === '6'){
    const files = await build6Files(window._fftState);
    files.forEach(f=>triggerDownload(f.blob, f.name));
    log('Saved 6 files');
  } else {
    const files = await build2Files(window._fftState);
    files.forEach(f=>triggerDownload(f.blob, f.name));
    log('Saved 2 compact files');
  }
});

function triggerDownload(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1500);
}

/* === ZIP (store) creation === */
function makeZipStore(files){
  const encoder = new TextEncoder();
  const crc32Table = (function(){
    const t = new Uint32Array(256);
    for(let i=0;i<256;i++){
      let c = i;
      for(let k=0;k<8;k++){
        if(c & 1) c = 0xEDB88320 ^ (c >>> 1);
        else c = c >>> 1;
      }
      t[i] = c >>> 0;
    }
    return t;
  })();
  const crc32 = (buf) => {
    let crc = 0 ^ (-1);
    for(let i=0;i<buf.length;i++){
      crc = (crc >>> 8) ^ crc32Table[(crc ^ buf[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
  };

  const readBlob = (b)=> new Promise(res=>{
    const fr = new FileReader();
    fr.onload = ()=> res(new Uint8Array(fr.result));
    fr.readAsArrayBuffer(b);
  });

  return (async ()=>{
    const parts = [];
    const centralParts = [];
    let offset = 0;
    for(const f of files){
      const content = await readBlob(f.blob);
      const nameBuf = encoder.encode(f.name);
      const crc = crc32(content);
      const compressedSize = content.length;
      const uncompressedSize = content.length;

      const localHeader = new Uint8Array(30 + nameBuf.length);
      const lhView = new DataView(localHeader.buffer);
      let p=0;
      lhView.setUint32(p, 0x04034b50, true); p+=4;
      lhView.setUint16(p, 20, true); p+=2;
      lhView.setUint16(p, 0, true); p+=2;
      lhView.setUint16(p, 0, true); p+=2;
      lhView.setUint16(p, 0, true); p+=2;
      lhView.setUint16(p, 0, true); p+=2;
      lhView.setUint32(p, crc, true); p+=4;
      lhView.setUint32(p, compressedSize, true); p+=4;
      lhView.setUint32(p, uncompressedSize, true); p+=4;
      lhView.setUint16(p, nameBuf.length, true); p+=2;
      lhView.setUint16(p, 0, true); p+=2;
      localHeader.set(nameBuf, 30);

      parts.push(localHeader);
      parts.push(content);

      const central = new Uint8Array(46 + nameBuf.length);
      const cv = new DataView(central.buffer);
      let q=0;
      cv.setUint32(q, 0x02014b50, true); q+=4;
      cv.setUint16(q, 0x0314, true); q+=2;
      cv.setUint16(q, 20, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint32(q, crc, true); q+=4;
      cv.setUint32(q, compressedSize, true); q+=4;
      cv.setUint32(q, uncompressedSize, true); q+=4;
      cv.setUint16(q, nameBuf.length, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint16(q, 0, true); q+=2;
      cv.setUint32(q, 0, true); q+=4;
      cv.setUint32(q, offset, true); q+=4;
      central.set(nameBuf, 46);

      centralParts.push(central);

      offset += localHeader.length + content.length;
    }

    const centralSize = centralParts.reduce((s,p)=>s+p.length,0);
    const centralAll = new Uint8Array(centralSize);
    let cp=0; for(const c of centralParts){ centralAll.set(c,cp); cp+=c.length; }

    const eocd = new Uint8Array(22);
    const ev = new DataView(eocd.buffer);
    let r=0;
    ev.setUint32(r, 0x06054b50, true); r+=4;
    ev.setUint16(r, 0, true); r+=2;
    ev.setUint16(r, 0, true); r+=2;
    ev.setUint16(r, files.length, true); r+=2;
    ev.setUint16(r, files.length, true); r+=2;
    ev.setUint32(r, centralAll.length, true); r+=4;
    ev.setUint32(r, offset, true); r+=4;
    ev.setUint16(r, 0, true); r+=2;

    parts.push(centralAll);
    parts.push(eocd);

    const totalLen = parts.reduce((s,p)=>s+p.length,0);
    const out = new Uint8Array(totalLen);
    let o=0; for(const p of parts){ out.set(p,o); o+=p.length; }
    return new Blob([out], {type:'application/zip'});
  })();
}

/* === Save ZIP handler === */
saveZipBtn.addEventListener('click', async ()=>{
  if(!window._fftState){ log('No FFT state: run FFT first'); return; }
  log('Building 6 files for ZIP (this may take some seconds)...');
  const files = await build6Files(window._fftState);
  log('Packing into ZIP (store) ...');
  try{
    const zipBlob = await makeZipStore(files);
    const name = `fft_rgb_${timestampSuffix()}.zip`;
    triggerDownload(zipBlob, name);
    log('ZIP ready:', name);
  }catch(err){
    log('ZIP creation failed:', err && err.message);
  }
});

/* === Decoding / Reconstruction on load (auto-recognition of 2/6 files) === */
loadFilesInput.addEventListener('change', async (e)=>{
  const list = Array.from(e.target.files || []);
  if(list.length===0) return;
  log('Loading', list.length, 'files');
  const zipFiles = [];
  const pngFiles = [];
  for(const f of list){
    const ext = f.name.toLowerCase();
    if(ext.endsWith('.zip') || f.type==='application/zip') zipFiles.push(f);
    else pngFiles.push(f);
  }
  let allFiles = pngFiles.slice();
  if(zipFiles.length>0){
    for(const z of zipFiles){
      const unpacked = await unpackZipStore(z);
      unpacked.forEach(x=>allFiles.push(new File([x.blob], x.name, {type:'image/png'})));
    }
  }
  log('Total PNG files to process:', allFiles.length);
  const loaded = {};
  for(const f of allFiles){
    try{
      const meta = await inspectPngMeta(f);
      if(meta){ log('Meta code', meta.code, 'from', f.name); } else { log('No meta detected in', f.name); }
      loaded[f.name] = { file:f, meta };
    }catch(err){ log('Error reading', f.name, err && err.message); }
  }
  const names = Object.keys(loaded);
  const have6 = names.some(n=>n.includes('amp_r')) && names.some(n=>n.includes('phase_r'));
  const have2 = names.some(n=>n.includes('amp_rgb')) && names.some(n=>n.includes('phase_rgb'));
  if(have2){
    const ampFile = allFiles.find(f=>f.name.includes('amp_rgb'));
    const phaseFile = allFiles.find(f=>f.name.includes('phase_rgb'));
    const ampDecoded = await decodeAmpRGB(ampFile);
    const phaseDecoded = await decodePhaseRGB(phaseFile);
    await reconstructFromDecoded(ampDecoded, phaseDecoded);
    log('Reconstructed from 2-file compact mode');
    return;
  }
  if(have6){
    const map = {};
    for(const f of allFiles){
      const n = f.name.toLowerCase();
      if(n.includes('amp_r')) map.amp_r = await decode24bitPNG(f);
      if(n.includes('amp_g')) map.amp_g = await decode24bitPNG(f);
      if(n.includes('amp_b')) map.amp_b = await decode24bitPNG(f);
      if(n.includes('phase_r')) map.phase_r = await decode24bitPNG(f);
      if(n.includes('phase_g')) map.phase_g = await decode24bitPNG(f);
      if(n.includes('phase_b')) map.phase_b = await decode24bitPNG(f);
    }
    if(map.amp_r && map.amp_g && map.amp_b && map.phase_r && map.phase_g && map.phase_b){
      const ampDecoded = { amp_r:map.amp_r, amp_g:map.amp_g, amp_b:map.amp_b };
      const phaseDecoded = { phase_r:map.phase_r, phase_g:map.phase_g, phase_b:map.phase_b };
      await reconstructFromDecoded(ampDecoded, phaseDecoded);
      log('Reconstructed from 6-file mode');
      return;
    } else {
      log('Missing some files for 6-file reconstruction');
    }
  }
  log('Unable to find a complete set for automatic reconstruction; try uploading appropriate files or ZIP with correct filenames');
});

/* === PNG inspection and decoding helpers === */
async function inspectPngMeta(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  return await new Promise((resolve, reject)=>{
    img.onload = ()=>{
      URL.revokeObjectURL(url);
      const cvs = document.createElement('canvas');
      cvs.width = W; cvs.height = H+1;
      const ctx = cvs.getContext('2d');
      ctx.drawImage(img, 0,0, cvs.width, cvs.height);
      try{
        const id = ctx.getImageData(0,0,cvs.width,1);
        const pixels = id.data;
        const headerBytes = [];
        for(let i=0, p=0; i<Math.min(64, Math.floor(pixels.length/4)); i++, p+=4){
          headerBytes.push(pixels[p], pixels[p+1], pixels[p+2]);
        }
        const b16 = headerBytes[16]; const b24 = headerBytes[24]; const b48 = headerBytes[48];
        let code = null;
        if(b16 && b16>=1 && b16<=6) code = b16;
        else if(b24===21) code = 21;
        else if(b48===22) code = 22;
        resolve({code, headerBytes});
      }catch(err){
        reject(err);
      }
    };
    img.onerror = ()=>{ URL.revokeObjectURL(url); reject(new Error('Image load failed')); };
    img.src = url;
  });
}

async function decode24bitPNG(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  return await new Promise((resolve,reject)=>{
    img.onload = ()=>{
      URL.revokeObjectURL(url);
      const cvs = document.createElement('canvas'); cvs.width = W; cvs.height = H+1;
      const ctx = cvs.getContext('2d');
      ctx.drawImage(img,0,0,cvs.width,cvs.height);
      const firstRow = ctx.getImageData(0,0,cvs.width,1).data;
      const headerBytes = new Uint8Array(18);
      for(let i=0;i<6;i++){
        headerBytes[i*3+0] = firstRow[i*4+0];
        headerBytes[i*3+1] = firstRow[i*4+1];
        headerBytes[i*3+2] = firstRow[i*4+2];
      }
      const dv = new DataView(headerBytes.buffer);
      const a = dv.getFloat64(0,true);
      const b = dv.getFloat64(8,true);
      const code = headerBytes[16];
      const body = ctx.getImageData(0,1,cvs.width,H).data;
      const out = new Float32Array(W*H);
      if(code>=1 && code<=6){
        for(let i=0, p=0;i<W*H;i++, p+=4){
          const R = body[p], G = body[p+1], B = body[p+2];
          const v24 = (R<<16) | (G<<8) | B;
          out[i] = v24 / 16777215;
        }
        if(code%2===1){
          resolve({meta:{type:'amp',maxAmp:a,code,filename:file.name}, norm:out});
        } else {
          resolve({meta:{type:'phase',minPhase:a,maxPhase:b,code,filename:file.name}, norm:out});
        }
      } else {
        resolve(null);
      }
    };
    img.onerror = ()=>{ URL.revokeObjectURL(url); reject(new Error('Image load error')); };
    img.src = url;
  });
}

async function decodeAmpRGB(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  return await new Promise((resolve,reject)=>{
    img.onload = ()=>{
      URL.revokeObjectURL(url);
      const cvs = document.createElement('canvas'); cvs.width = W; cvs.height = H+1;
      const ctx = cvs.getContext('2d');
      ctx.drawImage(img,0,0,cvs.width,cvs.height);
      const firstRow = ctx.getImageData(0,0,cvs.width,1).data;
      const headerBytes = new Uint8Array(27);
      for(let i=0;i<9;i++){
        headerBytes[i*3+0] = firstRow[i*4+0];
        headerBytes[i*3+1] = firstRow[i*4+1];
        headerBytes[i*3+2] = firstRow[i*4+2];
      }
      const dv = new DataView(headerBytes.buffer);
      const ampMaxR = dv.getFloat64(0,true);
      const ampMaxG = dv.getFloat64(8,true);
      const ampMaxB = dv.getFloat64(16,true);
      const code = headerBytes[24];
      const body = ctx.getImageData(0,1,cvs.width,H).data;
      const outR = new Float32Array(W*H), outG = new Float32Array(W*H), outB = new Float32Array(W*H);
      for(let i=0, p=0;i<W*H;i++, p+=4){
        outR[i] = body[p] / 255; outG[i] = body[p+1] / 255; outB[i] = body[p+2] / 255;
      }
      resolve({meta:{type:'amp_rgb',ampMax:{r:ampMaxR,g:ampMaxG,b:ampMaxB},code,filename:file.name}, norm:{r:outR,g:outG,b:outB}});
    };
    img.onerror = ()=>{ URL.revokeObjectURL(url); reject(new Error('Image load error')); };
    img.src = url;
  });
}

async function decodePhaseRGB(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  return await new Promise((resolve,reject)=>{
    img.onload = ()=>{
      URL.revokeObjectURL(url);
      const cvs = document.createElement('canvas'); cvs.width = W; cvs.height = H+1;
      const ctx = cvs.getContext('2d');
      ctx.drawImage(img,0,0,cvs.width,cvs.height);
      const firstRow = ctx.getImageData(0,0,cvs.width,1).data;
      const headerBytes = new Uint8Array(51);
      for(let i=0;i<17;i++){
        headerBytes[i*3+0] = firstRow[i*4+0];
        headerBytes[i*3+1] = firstRow[i*4+1];
        headerBytes[i*3+2] = firstRow[i*4+2];
      }
      const dv = new DataView(headerBytes.buffer);
      let off = 0;
      const minR = dv.getFloat64(off,true); off+=8;
      const maxR = dv.getFloat64(off,true); off+=8;
      const minG = dv.getFloat64(off,true); off+=8;
      const maxG = dv.getFloat64(off,true); off+=8;
      const minB = dv.getFloat64(off,true); off+=8;
      const maxB = dv.getFloat64(off,true); off+=8;
      const code = headerBytes[48];
      const body = ctx.getImageData(0,1,cvs.width,H).data;
      const outR = new Float32Array(W*H), outG = new Float32Array(W*H), outB = new Float32Array(W*H);
      for(let i=0, p=0;i<W*H;i++, p+=4){
        outR[i] = body[p] / 255; outG[i] = body[p+1] / 255; outB[i] = body[p+2] / 255;
      }
      resolve({meta:{type:'phase_rgb',phaseRanges:{r:[minR,maxR],g:[minG,maxG],b:[minB,maxB]},code,filename:file.name}, norm:{r:outR,g:outG,b:outB}});
    };
    img.onerror = ()=>{ URL.revokeObjectURL(url); reject(new Error('Image load error')); };
    img.src = url;
  });
}

/* === Reconstruction === */
async function reconstructFromDecoded(ampDecoded, phaseDecoded){
  log('Reconstruction: preparing complex arrays');
  const A = { r:new Float32Array(W*H), g:new Float32Array(W*H), b:new Float32Array(W*H) };
  const PH = { r:new Float32Array(W*H), g:new Float32Array(W*H), b:new Float32Array(W*H) };

  if(ampDecoded.meta && ampDecoded.meta.type === 'amp_rgb' && phaseDecoded.meta && phaseDecoded.meta.type === 'phase_rgb'){
    for(let i=0;i<W*H;i++){
      A.r[i] = ampDecoded.norm.r[i] * ampDecoded.meta.ampMax.r;
      A.g[i] = ampDecoded.norm.g[i] * ampDecoded.meta.ampMax.g;
      A.b[i] = ampDecoded.norm.b[i] * ampDecoded.meta.ampMax.b;
      PH.r[i] = phaseDecoded.norm.r[i] * (phaseDecoded.meta.phaseRanges.r[1] - phaseDecoded.meta.phaseRanges.r[0]) + phaseDecoded.meta.phaseRanges.r[0];
      PH.g[i] = phaseDecoded.norm.g[i] * (phaseDecoded.meta.phaseRanges.g[1] - phaseDecoded.meta.phaseRanges.g[0]) + phaseDecoded.meta.phaseRanges.g[0];
      PH.b[i] = phaseDecoded.norm.b[i] * (phaseDecoded.meta.phaseRanges.b[1] - phaseDecoded.meta.phaseRanges.b[0]) + phaseDecoded.meta.phaseRanges.b[0];
    }
  } else if(ampDecoded.amp_r){
    const ar = ampDecoded.amp_r, ag = ampDecoded.amp_g, ab = ampDecoded.amp_b;
    const pr = phaseDecoded.phase_r, pg = phaseDecoded.phase_g, pb = phaseDecoded.phase_b;
    for(let i=0;i<W*H;i++){
      A.r[i] = ar.norm[i] * ar.meta.maxAmp;
      A.g[i] = ag.norm[i] * ag.meta.maxAmp;
      A.b[i] = ab.norm[i] * ab.meta.maxAmp;
      PH.r[i] = pr.norm[i] * (pr.meta.maxPhase - pr.meta.minPhase) + pr.meta.minPhase;
      PH.g[i] = pg.norm[i] * (pg.meta.maxPhase - pg.meta.minPhase) + pg.meta.minPhase;
      PH.b[i] = pb.norm[i] * (pb.meta.maxPhase - pb.meta.minPhase) + pb.meta.minPhase;
    }
  } else {
    log('Unsupported decoded data shape for reconstruction'); return;
  }

  log('Building complex arrays (Re/Im) and running inverse FFT');
  const reR = new Float32Array(W*H), imR = new Float32Array(W*H);
  const reG = new Float32Array(W*H), imG = new Float32Array(W*H);
  const reB = new Float32Array(W*H), imB = new Float32Array(W*H);
  for(let i=0;i<W*H;i++){
    reR[i] = A.r[i] * Math.cos(PH.r[i]); imR[i] = A.r[i] * Math.sin(PH.r[i]);
    reG[i] = A.g[i] * Math.cos(PH.g[i]); imG[i] = A.g[i] * Math.sin(PH.g[i]);
    reB[i] = A.b[i] * Math.cos(PH.b[i]); imB[i] = A.b[i] * Math.sin(PH.b[i]);
  }
  const t0 = performance.now();
  fft2d(reR, imR, true);
  fft2d(reG, imG, true);
  fft2d(reB, imB, true);
  const t1 = performance.now();
  log('Inverse FFT done in', Math.round(t1-t0),'ms');
  const outImg = canvasRecon;
  const ctx = outImg.getContext('2d');
  const id = ctx.createImageData(W,H);
  let rmin=Infinity,rmax=-Infinity,gmin=Infinity,gmax=-Infinity,bmin=Infinity,bmax=-Infinity;
  for(let i=0;i<W*H;i++){
    const rv = reR[i], gv = reG[i], bv = reB[i];
    if(rv<rmin) rmin=rv; if(rv>rmax) rmax=rv;
    if(gv<gmin) gmin=gv; if(gv>gmax) gmax=gv;
    if(bv<bmin) bmin=bv; if(bv>bmax) bmax=bv;
  }
  if(!isFinite(rmin)||!isFinite(rmax)) { rmin=0; rmax=1; }
  if(!isFinite(gmin)||!isFinite(gmax)) { gmin=0; gmax=1; }
  if(!isFinite(bmin)||!isFinite(bmax)) { bmin=0; bmax=1; }
  const rDen = (rmax-rmin)||1, gDen = (gmax-gmin)||1, bDen = (bmax-bmin)||1;
  for(let i=0, p=0;i<W*H;i++, p+=4){
    const rr = Math.round((reR[i]-rmin)/rDen * 255);
    const gg = Math.round((reG[i]-gmin)/gDen * 255);
    const bb = Math.round((reB[i]-bmin)/bDen * 255);
    id.data[p] = clampByte(rr); id.data[p+1] = clampByte(gg); id.data[p+2] = clampByte(bb); id.data[p+3]=255;
  }
  ctx.putImageData(id,0,0);
  const dataUrl = outImg.toDataURL('image/png');
  imgRecon.src = dataUrl;
  imgRecon.alt = 'reconstructed image';
  imgRecon.width = 320;
  dlRecon.onclick = ()=>{ triggerDownload(dataURItoBlob(dataUrl), `recon_${timestampSuffix()}.png`); };
  dlReconData.onclick = ()=>{ navigator.clipboard && navigator.clipboard.writeText(dataUrl).then(()=>log('dataURL copied')); };
  log('Reconstruction finished and displayed');
}

/* === dataURI / blob helpers === */
function dataURItoBlob(dataURI){
  const byteString = atob(dataURI.split(',')[1]);
  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for(let i=0;i<byteString.length;i++) ia[i] = byteString.charCodeAt(i);
  return new Blob([ab], {type:mimeString});
}

/* === ZIP unpack (minimal) === */
async function unpackZipStore(zipFile){
  const buf = await fileToUint8(zipFile);
  const dv = new DataView(buf.buffer);
  let p = 0;
  const files = [];
  while(p < buf.length - 30){
    const sig = dv.getUint32(p, true);
    if(sig !== 0x04034b50) break;
    const compressedSize = dv.getUint32(p+18, true);
    const nameLen = dv.getUint16(p+26, true);
    const extraLen = dv.getUint16(p+28, true);
    const nameStart = p + 30;
    const name = new TextDecoder().decode(buf.slice(nameStart, nameStart + nameLen));
    const dataStart = nameStart + nameLen + extraLen;
    const filedata = buf.slice(dataStart, dataStart + compressedSize);
    files.push({name, blob: new Blob([filedata], {type:'application/octet-stream'})});
    p = dataStart + compressedSize;
  }
  log('Unpacked', files.length, 'files from ZIP');
  return files;
}
function fileToUint8(f){ return new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(new Uint8Array(fr.result)); fr.readAsArrayBuffer(f); }); }

/* === Generate links (auto after FFT) === */
async function generateAndShowLinks(mode){
  linksArea.innerHTML='';
  if(!window._fftState){ log('No FFT state'); return; }
  if(mode==='6'){
    const files = await build6Files(window._fftState);
    files.forEach(f=>{
      const url = URL.createObjectURL(f.blob);
      const a = document.createElement('a'); a.href = url; a.innerText = f.name; a.target='_blank'; a.download = f.name;
      a.style.background='#0b2b3b'; a.style.padding='6px 8px'; a.style.borderRadius='8px'; a.style.color='#dff';
      a.onclick = ()=> setTimeout(()=>URL.revokeObjectURL(url),1500);
      linksArea.appendChild(a);
    });
    log('Generated 6 links (preview)');
  } else {
    const files = await build2Files(window._fftState);
    files.forEach(f=>{
      const url = URL.createObjectURL(f.blob);
      const a = document.createElement('a'); a.href = url; a.innerText = f.name; a.target='_blank'; a.download = f.name;
      a.style.background='#0b2b3b'; a.style.padding='6px 8px'; a.style.borderRadius='8px'; a.style.color='#dff';
      a.onclick = ()=> setTimeout(()=>URL.revokeObjectURL(url),1500);
      linksArea.appendChild(a);
    });
    log('Generated 2 links (preview)');
  }
}

/* === Base64 -> PNG converter === */
convBase64.addEventListener('click', ()=>{
  const v = base64in.value.trim();
  if(!v){ log('Empty base64 input'); return; }
  let dataUrl = v;
  if(!v.startsWith('data:')) dataUrl = 'data:image/png;base64,' + v.replace(/\s+/g,'');
  try{
    const blob = dataURItoBlob(dataUrl);
    const url = URL.createObjectURL(blob);
    base64Preview.innerHTML = '';
    const a = document.createElement('a'); a.href=url; a.download=`base64_${timestampSuffix()}.png`; a.target='_blank'; a.innerText='Open PNG'; a.style.padding='6px 8px'; a.style.background='#0b2b3b'; a.style.color='#dff'; a.style.borderRadius='8px';
    const img = document.createElement('img'); img.src = url; img.style.maxWidth='240px'; img.style.display='block'; img.style.marginTop='8px'; img.alt='base64 preview';
    base64Preview.appendChild(a); base64Preview.appendChild(img);
    log('Base64 converted to PNG preview');
    setTimeout(()=>URL.revokeObjectURL(url),60000);
  }catch(err){ log('Base64 convert error', err && err.message); }
});
clearBase64.addEventListener('click', ()=>{ base64in.value=''; base64Preview.innerHTML=''; });

/* === Logging ready === */
log('App ready — links, zip, base64, reconstruction supported');

/* =========================
   Camera ZIP Mode integration
   - встроен в тот же скрипт, использует локальные функции напрямую
   - не изменяет существующие имена функций и поведение
   ========================= */
(function cameraZipIntegration(){
  const camStartBtn = document.getElementById('camStartBtn');
  const camStopBtn  = document.getElementById('camStopBtn');
  const camCaptureZipBtn = document.getElementById('camCaptureZipBtn');
  const camPreview = document.getElementById('camPreview');
  const camCanvas = document.getElementById('camCanvas');
  const camStatus = document.getElementById('camStatus');

  let stream = null;

  function setStatus(s){ camStatus.innerText = s; log('[Camera] ' + s); }

  camStartBtn.addEventListener('click', async ()=>{
    try{
      setStatus('Requesting camera permission...');
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false });
      camPreview.srcObject = stream;
      camPreview.style.display = 'block';
      camStopBtn.disabled = false;
      camCaptureZipBtn.disabled = false;
      camStartBtn.disabled = true;
      setStatus('Camera started');
    }catch(err){
      setStatus('Camera start failed: ' + (err && err.message || err));
    }
  });

  camStopBtn.addEventListener('click', ()=>{
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }
    camPreview.pause();
    camPreview.srcObject = null;
    camPreview.style.display = 'none';
    camStopBtn.disabled = true;
    camCaptureZipBtn.disabled = true;
    camStartBtn.disabled = false;
    setStatus('Camera stopped');
  });

  function captureVideoFrameToImage(){
    const vw = camPreview.videoWidth || 1280;
    const vh = camPreview.videoHeight || 720;
    const tmp = document.createElement('canvas');
    tmp.width = vw; tmp.height = vh;
    const ctx = tmp.getContext('2d');
    ctx.drawImage(camPreview, 0, 0, tmp.width, tmp.height);
    const img = new Image();
    img.src = tmp.toDataURL('image/png');
    return new Promise((res, rej)=>{
      img.onload = ()=> res(img);
      img.onerror = (e)=> rej(e);
    });
  }

  camCaptureZipBtn.addEventListener('click', async ()=>{
    if(!stream){ setStatus('Camera not running'); return; }
    camCaptureZipBtn.disabled = true;
    setStatus('Capturing frame...');
    try{
      const img = await captureVideoFrameToImage();
      setStatus('Frame captured — preparing 1024x1024 and running FFT');

      // prepareImageTo1024 доступна в этом скрипте
      prepareImageTo1024(img);

      // запустить FFT: reuse существующий обработчик (doFftBtn)
      // очистим предыдущее состояние и симулируем клик, затем ждём window._fftState
      window._fftState = null;
      doFftBtn.click();
      setStatus('FFT started — waiting for completion...');
      const waitForState = (timeoutMs = 60000) => new Promise((resolve, reject)=>{
        const start = Date.now();
        const iv = setInterval(()=>{
          if(window._fftState){
            clearInterval(iv); resolve(window._fftState);
          } else if(Date.now() - start > timeoutMs){
            clearInterval(iv); reject(new Error('FFT timeout'));
          }
        }, 200);
      });
      const state = await waitForState();
      setStatus('FFT finished — building 6 PNGs and packing ZIP');
      const files = await build6Files(state);
      const zipBlob = await makeZipStore(files);
      const name = `cam_zip_${timestampSuffix()}.zip`;
      triggerDownload(zipBlob, name);
      setStatus('ZIP created and download triggered: ' + name);
    }catch(err){
      setStatus('Capture & ZIP failed: ' + (err && err.message || err));
    }finally{
      camCaptureZipBtn.disabled = false;
    }
  });

  window.addEventListener('beforeunload', ()=>{
    if(stream) stream.getTracks().forEach(t=>t.stop());
  });
})();

/* Конец скрипта */
</script>
</body>
</html>
